{"version":3,"file":"static/js/4110.06ebd97a.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/nonChromiumPlatformUtils.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.7\n */\nimport { e as rectToClientRect } from './floating-ui.js';\n\n/**\n * This module provides utils to fix positioning across shadow DOM in non-Chromium browsers\n *\n * It is based on floating-ui's distributable\n */\n/**\n * üëá the following are needed to fix shadow DOM positioning üëáÔ∏è\n *\n * @param element\n */\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n *\n * @param element\n */\nfunction composedOffsetParent(element) {\n  let { offsetParent } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n  while (ancestor && ancestor !== offsetParent) {\n    const { assignedSlot } = ancestor;\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n      if (getComputedStyle(assignedSlot).display === \"contents\") {\n        const hadStyleAttribute = assignedSlot.hasAttribute(\"style\");\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute(\"style\");\n        }\n      }\n      ancestor = assignedSlot;\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    }\n    else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n    ancestor = (isShadowRoot(ancestor) && ancestor.host) || ancestor.parentNode;\n  }\n  return offsetParent;\n}\nfunction getElementRects(_ref) {\n  const { reference, floating, strategy } = _ref;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n    floating: { ...getDimensions(floating), x: 0, y: 0 }\n  };\n}\n/**\n * ‚òùÔ∏è the following are needed to fix shadow DOM positioning ‚òùÔ∏è\n */\n/**\n * üëá the following are taken directly from floating-ui's ESM distributable to support the exports above üëáÔ∏è\n *\n * **Notes**:\n * unused functions are removed\n * ESLint is disabled\n * TS-warnings are suppressed\n */\n/* eslint-disable */\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n  // @ts-ignore\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n  return (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display));\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return (css.transform !== \"none\" ||\n    css.perspective !== \"none\" ||\n    (isFirefox && css.willChange === \"filter\") ||\n    (isFirefox && (css.filter ? css.filter !== \"none\" : false)) ||\n    [\"transform\", \"perspective\"].some((value) => css.willChange.includes(value)) ||\n    [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    // TS 4.1 compat\n    (value) => {\n      const contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    }));\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // ‚Ä¢ Always-visible scrollbar or not\n  // ‚Ä¢ Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left +\n    (addVisualOffsets\n      ? (_win$visualViewport$o =\n        (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null\n        ? _win$visualViewport$o\n        : 0\n      : 0)) /\n    scaleX;\n  const y = (clientRect.top +\n    (addVisualOffsets\n      ? (_win$visualViewport$o2 =\n        (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null\n        ? _win$visualViewport$o2\n        : 0\n      : 0)) /\n    scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // @ts-ignore\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && strategy !== \"fixed\")) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      // @ts-ignore\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  return (\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  // @ts-ignore\n  node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || // DOM Element detected\n    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n  );\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent &&\n    (getNodeName(offsetParent) === \"html\" ||\n      (getNodeName(offsetParent) === \"body\" &&\n        getComputedStyle(offsetParent).position === \"static\" &&\n        !isContainingBlock(offsetParent)))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || (!layoutViewport && strategy === \"fixed\")) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody\n    ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n    : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList // @ts-ignore: isBody tells us target will be an HTMLElement here\n    : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && [\"absolute\", \"fixed\"].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n  return currentNode;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n  // @ts-ignore\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    }\n    else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n  return clippingAncestors.filter((clippingAncestors) => clipperElement &&\n    isElement(clippingAncestors) &&\n    contains(clippingAncestors, clipperElement) &&\n    getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let { element, boundary, rootBoundary, strategy } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nexport { getClippingRect, getElementRects, getOffsetParent };\n"],"names":["getTrueOffsetParent","element","isHTMLElement","getComputedStyle","position","offsetParent","ancestor","foundInsideSlot","assignedSlot","newOffsetParent","display","hadStyleAttribute","hasAttribute","oldDisplay","style","removeAttribute","isShadowRoot","host","parentNode","composedOffsetParent","getElementRects","_ref","reference","floating","strategy","getRectRelativeToOffsetParent","getOffsetParent","_objectSpread","getDimensions","x","y","isWindow","value","document","location","alert","setInterval","getWindow","node","window","ownerDocument","defaultView","getNodeName","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","brands","map","item","brand","version","join","userAgent","HTMLElement","isElement","Element","ShadowRoot","isOverflowElement","_getComputedStyle","overflow","overflowX","overflowY","test","includes","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","willChange","filter","some","contain","isLayoutViewport","isLastTraversableNode","min","Math","max","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","offsetWidth","width","offsetHeight","height","win","addVisualOffsets","left","visualViewport","offsetLeft","top","offsetTop","right","bottom","getDocumentElement","Node","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","isOffsetParentAnElement","rect","isScaled","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","currentNode","parent","getContainingBlock","getNearestOverflowAncestor","body","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","concat","updatedList","getClientRectFromClippingAncestor","clippingParent","rectToClientRect","html","clientWidth","clientHeight","layoutViewport","getViewportRect","getInnerBoundingClientRect","_element$ownerDocumen","scrollWidth","scrollHeight","direction","getDocumentRect","getClippingAncestors","clippingAncestors","nearestEscapableParent","getNearestParentCapableOfEscapingClipping","clipperElement","child","rootNode","getRootNode","contains","next","getClippingRect","boundary","rootBoundary","mainClippingAncestors","_toConsumableArray","firstClippingAncestor","clippingRect","reduce","accRect","clippingAncestor"],"sourceRoot":""}